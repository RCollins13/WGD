{
    "collab_server" : "",
    "contents" : "#!/usr/bin/env Rscript\n\n# Copyright (c) 2016 Ryan Collins <rcollins@chgr.mgh.harvard.edu>\n# Distributed under terms of the MIT license.\n\n# Script to calculate median bin coverage per sample for all samples in a bincov\n# matrix\n\n# Note: loads entire coverage matrix into memory. This may pose a problem for\n# large matrices or on small-memory machines. Other workarounds exist from the\n# command line, but most are slower. One suggested alternative is to split\n# the input coverage matrices by chromosome prior to computing medians.\n\n# Load library\nrequire(optparse)\n\n# Define options\noption_list <- list(\n  make_option(c(\"-b\",\"--binwise\"), action=\"store_true\", default=FALSE,\n              help=\"compute medians of all samples per bin [default: median of all bins per sample]\"),\n  make_option(c(\"-m\",\"--mad\"), action=\"store_true\", default=FALSE,\n              help=\"compute median absolute deviation of all bins per sample [default: FALSE]\"),\n  make_option(c(\"-H\",\"--header\"), action=\"store_true\", default=FALSE,\n              help=\"input coverage matrix has header with sample IDs [default: FALSE]\"))\n\n# Get command-line arguments and options\nargs <- parse_args(OptionParser(usage=\"%prog [options] covMatrix.bed OUTFILE\",\n                                option_list=option_list),\n                   positional_arguments=TRUE)\nopts <- args$options\n\n# Checks for appropriate positional arguments\nif(length(args$args) != 2)\n{cat(\"Incorrect number of required positional arguments\\n\\n\")\n  stop()}\n\n# Read matrix\nif(opts$header==T){\n  cov <- read.table(args$args[1], header=T, comment.char=\"\")\n}else{\n  cov <- read.table(args$args[1], header=F, comment.char=\"#\")\n}\n\n# Function to compute medians per sample\ncovPerSample <- function(cov,downsample=1000000,mad=F){\n  # Downsample to 1M random rows if nrows > 1M (for computational efficiency)\n  if(nrow(cov)>1000000){\n    cov <- cov[sample(1:nrow(cov), downsample),]\n  }\n  # Get medians with and without zero-cov bins\n  zerobins <- which(as.integer(apply(as.data.frame(cov[,-c(1:3)]), 1, median)) == 0)\n  withzeros <- as.numeric(apply(as.data.frame(cov[,-c(1:3)]), 2, median))\n  withoutzeros <- as.numeric(apply(as.data.frame(cov[-zerobins,-c(1:3)]), 2, median))\n  #Get SDs with and without zero-cov bins (if optioned)\n  if(mad==T){\n    withzeros.mad <- as.numeric(apply(as.data.frame(cov[,-c(1:3)]), 2, mad))\n    withoutzeros.mad <- as.numeric(apply(as.data.frame(cov[-zerobins,-c(1:3)]), 2, mad))\n  }\n  # Compile results df to return\n  if(mad==T){\n    res <- data.frame(\"ID\"=paste(\"Sample\",1:(ncol(cov)-3),sep=\"\"),\n                      \"Med_withZeros\"=withzeros,\n                      \"Med_withoutZeros\"=withoutzeros,\n                      \"MAD_withZeros\"=withzeros.mad,\n                      \"MAD_withoutZeros\"=withoutzeros.mad)\n  }else{\n    res <- data.frame(\"ID\"=paste(\"Sample\",1:(ncol(cov)-3),sep=\"\"),\n                      \"Med_withZeros\"=withzeros,\n                      \"Med_withoutZeros\"=withoutzeros)\n  }\n  # Replace sample IDs if input matrix has header\n  if(opts$header==T){\n    res$ID <- names(cov[,-c(1:3)])\n  }\n  # Return output df\n  return(res)\n}\n\n# Function to compute medians per bin\ncovPerBin <- function(cov,downsample=500,mad=F){\n  # Downsample to 500 random samples if nsamples > 500 (for computational efficiency)\n  if(ncol(cov)>503){\n    cov <- cov[,sample(1:ncol(cov), downsample)]\n  }\n  # Get medians with and without zero-cov samples\n  meds <- t(apply(as.data.frame(cov[,-c(1:3)]), 1, function(vals){\n    withzeros <- median(vals)\n    if(any(vals>0)){\n      withoutzeros <- median(vals[which(vals>0)])\n    }else{\n      withoutzeros <- NA\n    }\n    return(c(withzeros,withoutzeros))\n  }))\n  # Get standard deviations (if optioned)\n  sds <- t(apply(as.data.frame(cov[,-c(1:3)]), 1, function(vals){\n    withzeros <- mad(vals)\n    if(any(vals>0)){\n      withoutzeros <- mad(vals[which(vals>0)])\n    }else{\n      withoutzeros <- NA\n    }\n    return(c(withzeros,withoutzeros))\n  }))\n  # compile results df to return\n  if(mad==T){\n    res <- data.frame(\"#chr\"=cov[,1],\"start\"=cov[,2],\"end\"=cov[,3],\n                      \"Med_withZeros\"=meds[,1],\n                      \"Med_withoutZeros\"=meds[,2],\n                      \"MAD_withZeros\"=sds[,1],\n                      \"MAD_withoutZeros\"=sds[,2])\n  }else{\n    res <- data.frame(\"#chr\"=cov[,1],\"start\"=cov[,2],\"end\"=cov[,3],\n                      \"Med_withZeros\"=meds[,1],\n                      \"Med_withoutZeros\"=meds[,2])\n  }\n  # Return output df\n  return(res)\n}\n\n# Compute appropriate medians & write out\nif(opts$binwise==TRUE){\n  res <- covPerBin(cov,mad=opts$mad)\n  names(res)[1] <- \"#chr\"\n  write.table(res,args$args[2], sep=\"\\t\", col.names=T, row.names=F, quote=F)\n}else{\n  res <- covPerSample(cov,mad=opts$mad)\n  names(res)[1] <- \"#ID\"\n  write.table(res,args$args[2], sep=\"\\t\", col.names=T, row.names=F, quote=F)\n}\n",
    "created" : 1493756477714.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2910901794",
    "id" : "C4239C59",
    "lastKnownWriteTime" : 1493772051,
    "last_content_update" : 1493772051277,
    "path" : "~/Desktop/Collins/Talkowski/code/WGD/bin/medianCoverage.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}