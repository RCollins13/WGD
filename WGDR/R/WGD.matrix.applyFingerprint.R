# Copyright (c) 2016 Ryan L. Collins <rlcollins@g.harvard.edu>
# Distributed under terms of the MIT license.

# WGD R Companion Library (WGDR) Function

################
# WGD.matrix.applyFingerprint
################
# Classifies samples in a coverage matrix based on GMM fit from WGD fingerprint
################
# Returns a data frame with the following columns:
#  $exp : expected classification (optional; default NA)
#  $obs : assigned classification by GMM fingerprint
#  $p : probability of assignment
#  $mag : magnitude of bias
################

WGD.matrix.applyFingerprint <- function(mat,           #WGD matrix object. Must be read with WGD.matrix.read
                                        fingerprint,   #WGD fingerprint generated by WGD.fingerprint
                                        exp.assign=NA, #vector with expected assignments of all samples in matrix (optional)
                                        quiet=F        #option to disable verbose output
){
  #Validate exp.assign argument
  if(all(!is.na(exp.assign))){
    if(length(setdiff(levels(as.factor(exp.assign)),levels(fingerprint$model$class))>0)){
      stop(paste("WGDR::ERROR [",
                 strsplit(as.character(Sys.time()),split=" ")[[1]][2],
                 "]: expected assignment classes do not match default;",
                 " please reset group labels to 'A' and 'B'\n",sep=""))
    }
    if(length(exp.assign)!=(ncol(mat$mat)-3)){
      stop(paste("WGDR::ERROR [",
                 strsplit(as.character(Sys.time()),split=" ")[[1]][2],
                 "]: length of assignment vector does not match number of samples in matrix\n",sep=""))
    }
  }

  #Prohibit scientific notation & auto string factorization
  options(scipen=1000,
          stringsAsFactors=F)

  #Require mClust
  require(mclust)

  #Prints status
  if(quiet==F){
    cat(paste("WGDR::STATUS [",
              strsplit(as.character(Sys.time()),split=" ")[[1]][2],
              "]: applying fingerprint of ",nrow(fingerprint$fp.final),
              " bins to matrix of ",ncol(mat$mat)-3," samples\n",sep=""))
  }

  #Joins mat with fingerprint
  mat.fp <- merge(x=fingerprint$fp.final[,1:3],y=mat$res,all.x=T,all.y=F,sort=F,by.x=1:3)

  #Calculates median absolute residual per fp bin
  res.med <- apply(mat.fp[,-c(1:3)],2,function(res){
    return(median(abs(res)))
  })

  #Converts to scaled & transposed matrix
  test.matrix <- t(mat.fp[,-c(1:3)])
  test.matrix <- sapply(1:nrow(fingerprint$fp.final),function(i){
    #Apply identical scaling as used in training set
    test.matrix[,i] <- as.numeric((test.matrix[,i]-fingerprint$fp.final[i,]$mean)/fingerprint$fp.final[i,]$sd)
  })
  colnames(test.matrix) <- paste(fingerprint$fp.final[,1],fingerprint$fp.final[,2],fingerprint$fp.final[,3],sep="_")
  rownames(test.matrix) <- names(mat.fp)[-c(1:3)]

  #Classifies test matrix
  predictions <- predict(fingerprint$model,test.matrix)

  #Cleans expected labels
  if(any(is.na(exp.assign))){
    exp.assign <- rep("NA",times=length(predictions$classification))
  }else{
    exp.assign <- as.factor(exp.assign)
  }

  #Vectorizes GMM p values
  pvals <- sapply(1:nrow(predictions$z),function(i){
    if(as.character(predictions$classification[i])=="A"){
      return(predictions$z[i,1])
    }else{
      return(predictions$z[i,2])
    }
  })

  #Creates data frame with observed & expected labels
  results <- data.frame("exp"=exp.assign,
                        "obs"=predictions$classification,
                        "p"=pvals,
                        "mag"=res.med)
  rownames(results) <- rownames(test.matrix)

  #Returns result versus expected labels (if optioned)
  if(all(!(is.na(exp.assign)))){

    #Calculate testing accuracy
    TAdf <- data.frame("expA"=c(length(which(as.character(results$exp)=="A" &
                                            as.character(results$obs)=="A")),
                             length(which(as.character(results$exp)=="A" &
                                            as.character(results$obs)=="B"))),
                       "expB"=c(length(which(as.character(results$exp)=="B" &
                                            as.character(results$obs)=="A")),
                             length(which(as.character(results$exp)=="B" &
                                            as.character(results$obs)=="B"))))
    rownames(TAdf) <- c("obsA","obsB")
    TA <- (TAdf[1,2]+TAdf[2,1])/sum(TAdf)

    #Prints status
    if(quiet==F){
      cat(paste("WGDR::STATUS [",
                strsplit(as.character(Sys.time()),split=" ")[[1]][2],
                "]: testing accuracy of ",round(1-TA,4)," per expected labels as provided:\n",sep=""))
      print(TAdf)
    }
  }

  #Returns result
  return(results)
}
